<h1 id="MVCTutorial"><a href="#MVCTutorial">
    MVC Libruary for ExtendScript - Руководство
</a></h1>

***Status:*** *В разработке...* | ***Version:*** *0.1* | ***Last update:*** *13.05.2014*
> Фреймворк, реализующий паттерн MVC для JavaScript-приложений, разрабатываемых в среде **Adobe ExtendScript**.

<h3 id="TutorialIndex"><a href="#TutorialIndex">
    Оглавление
</a></h3>

* [Структура и состав библиотеки](#structureOflib)
* [Модуль MVC](#moduleMVC)
	* [MVCObject](#MObject)
	* [MVCApplication](#Application)
	* [MVCModel](#Model)
	* [MVCView](#View)
	* [MVCController](#Controller)
* [TODO:](#todomvc)
* [Contributing](#contrib)

Данная библиотека представляет набор модулей, позволяющий разрабатывать полноценные приложения для среды **Adobe ExtendScript** в полном соответствии с архитектурным паттерном **MVC** (**Model-View-Controller**) — **Модель-Представление**(Вид)**-Контролёр**.

Область применения включает как сложные приложения, требующие развитых возможностей по взаимодействию между пользователем, графическим интерфейсом и данными, так и совсем простые скрипты.

Основная идея, заложенная в библиотеку — позволить значительно сократить затраты и время на реализацию рутинных операций по связыванию данных в программе с элементами графического интерфейса, при этом — обеспечить надежное отделение пользовательского интерфейса от управляющей логики.

<h2 id="structureOflib"><a href="#structureOflib">
    Структура и состав библиотеки.
</a></h2>

Библиотека имеет модульную структуру. Общая архитектура и шаблон модулей подробно описаны [тут](#modtemplate). 
На данный момент библиотека состоит из двух основных MVC-модулей: **MVC** и **MVC.DOM** (им соответствуют заголовочные файлы *MVC.jsx* и *MVC.DOM.jsx*), а также широко использует отдельный модуль **Collection**, реализующий для ExtendScript коллекции, и пару инструментов общего назначения из [_dbug.jsx](#es_debug) и [_util.jsx](#es_util) (некоторые из которых благополучно перекочевали из underscore.js)

<h2 id="moduleMVC"><a href="#moduleMVC">
    Модуль MVC
</a></h2>


*MVC.jsx* содержит основной модуль MVC-Фреймворка и предоставляет в рамках своего пространства имён `MVC` пять основных объектов:

* [MVC.Object](#MObject) – базовый **MVC-объект**, являющийся родительским в отношении всех прочих MVC-объектов, доступен в глобальной области видимости как `MVCObject`;
* [MVC.Application](#Application) – объект **Приложение**, доступен в глобальной области видимости как `MVCApplication`;
* [MVC.Model](#Model) – объект **Модель**, доступен в глобальной области видимости как `MVCModel`;
* [MVC.View](#View) – объект **Представление**, доступен в глобальной области видимости как `MVCView`;
* [MVC.Controller](#Controller) – объект **Контролёр**, доступен в глобальной области видимости как `MVCController`.

Далее объекты `MVCModel`, `MVCView` и `MVCController` для краткости могут называться просто - **MVC-объектами**. 

<h4 id="Application"><a href="#Application">
    MVCObject
</a></h4>
Это родительский в отношении всего MVC-семейства объект. Сам по себе он обладает минимальной функциональностью - предоставляет свойство `id` и конструктор, который умеет устанавливать это свойство и расширять собственный экземпляр свойствами объекта, указанного в аргументе при вызове конструктора. Следующие примеры демонстрируют как он работает:

```js
var obj = new MVCObject ("obj"); // obj -> { id:"obj" }
var obj = new MVCObject ({ text:"obj1"}); // obj -> { id:"", text:"obj1" }
var obj = new MVCObject ({ id:"obj", text:"obj1"}); // obj -> { id:"obj", text:"obj1" 
```
Итак, любое текстовое значение рассматривается как значение для свойства `id` - персонального идентификатора объекта, любой объект, полученный в качестве аргумента, используется как источник свойств и значений, объединяемых с самим экземпляром `MVCObject`. При этом, свойство `id` будет в любом случае определено для экземпляра, и по-умолчанию его значением будет пустая строка.

Самостоятельно данный объект нигде не используется, его основное предназначение в том, чтобы предоставить общий прототип для всех MVC-объектов и, таким образом, иметь возможность их глобального расширения. Это в чём то напоминает роль объекта `Object` в javascript.

<h4 id="MObject"><a href="#MObject">
    MVCApplication
</a></h4>

Данный объект является основой - скелетом для всего приложения построенного в рамках архитектурного паттерна MVC. Он выполняет сразу несколько ролей: поддерживает коллекции всех MVC-объектов, создаваемых в рамках приложения; предоставляет интерфейс для создания, удаления и управления MVC-объектами; может выступать в качестве изолированного пространства имён для всего javascript—приложения в целом.

Общая структура приложения, предлагаемая данной MVC-библиотекой, может быть представлена в следующем коде:

```js
// Создание приложения:
var myApp = new MVCApplication(); // эквивалентно new MVC.Applicatiom();

// Инициализация:
myApp.Init = function() {
    // здесь можно создавать все необходимые компоненты приложения 
    // и размещать весь необходимый код для их инициализации:
    //... 

};

// Запуск приложения и вывод на экран его главного окна: 
myApp.run();
```
Метод `.run()` осуществляет запуск приложения, который предусматривает два действия:

* в первую очередь производится выполнение метода `.Init()`, предназначенного для начальной инициализации приложения;
* осуществляется вывод главного представления (диалогового окна) приложения на экран.

Каждый объект `MVCApplication` обладает собственным главным окном, которое формируется конструктором этого объекта. Окно представляет обычный ScriptUI-диалог, обладает всеми стандартными свойствами соответствующего ScriptUI объекта и, по умолчанию, имеет простой тип `dialog`, полученный путём вызова `new Window("dialog")`.

Конструктор объекта-приложения может принимать литерал объекта, с помощью которого можно на этапе создания Приложения задавать некоторые определённые его свойства и определять характеристики диалогового окна. Поля `name`, `version`, `caption` и `view` в литерале аргумента заранее предопределены, но все они имеют значения по умолчанию и допустимо не указывать любое из них, в том числе вполне возможно создать приложение путём вызова `var myApp = new MVC.Application();`. Полная сигнатура вызова конструктора имеет вид:

```js
var myApp = new MVC.Application({
    name:"Приложение MVC",
    version:"1.00",
    caption:"Приложение MVC (MVC v"+MVC.version+")",
    view:"palette { preferredSize:[350,200], properties:{resizeable:true} }"
});
```
В данном примере были определены имя и версия Приложения, а также определена надпись для заголовка окна, заданная в поле `caption`. По умолчанию данный заголовок, если он явно не определён, формируется автоматически путём конкатенции строк `name` и `version` (значения по умолчанию каждого представлены в примере). Кроме того, было определено свойство `view` - которое используется для формирования объекта-диалога. Оно представляет ресурсную строку в корректном для ScripUI формате, которая будет передана конструктору `Window()` для получения окна. В данном примере для Приложения будет сформировано масштабируемоё окно, имеющее тип `palette` с предустановленным размером 350х200 px. Следует отметить, что окно создаётся, но вывод его на экран не происходит вплоть до вызова метода `.run()`. 

В процессе создания объекта `MVCApplication`, значения полей, перечисленных в литерале аргумента, будут присвоены и доступны в соответствующих свойствах самого объекта:

* `MVCApplication.name: {string}`
* `MVCApplication.version: {string}`
* `MVCApplication.caption: {string}`
* `MVCApplication.view: {string}`

Для формирование окна конструктор использует вызов прототипного метода `.CreateMainView(rсString)`, который получает ресурсную строку для формирования диалога, полученную от свойства `view` (по умолчанию - *"dialog"*). В результате выполнения данного метода в объекте Приложения (MVCApplication) происходит инициализация свойств: `window` - которому присваивается ссылка на созданный объект-диалога (ScriptUI объект); и `mainView` - указывает на это же окно, но уже как на объект-представление (MVCView), оборачивающий ScriptUI объект-диалог (подробнее в описании MVCView). Кроме того, если потребуется, будет произведена вся необходимая работа по инициализации обработчиков `onResize()` и `onResizing()` объекта-диалога, которая требуется в ScriptUI для диалогов с установленным свойством **`resizeable:true`**.

Непосредственный вызов метода `CreateMainView()` можно использовать для полного контроля над процессом формирования главного окна приложения. Самое лучшее место для этого - в рамках метода `.Init()`:

```js
var app = new MVCApplication(); // эквивалентно new MVC.Applicatiom();

app.Init = function() {
    // Перестройка главного окна приложения:
    // окно изначально будет содержать надпись и редактируемое поле ввода
    app.CreateMainView("dialog { \
    	st:StaticText { text:'Статическая надпись'}, \
    	et:EditText { characters:25 } \
    	}");
	// после вызова свойство window указывает на созданный диалог:
	// текст в заголовке
    app.window.text = "Моё MVC-Приложение";
    // цвет статической надписи
    var gfx = app.window.et.graphics;
    gfx.foregroundColor = gfx.newPen(gfx.PenType.SOLID_COLOR, [1,0,0], 1);
    //... 

};

app.run();
```

В данном примере в качестве локального имени переменной было выбрано `app`, такая практика допустима, если Вы уверены, что Ваше приложение будет работать исключительно в окружении #target "estoolkit". В противном случае, запуская приложение под #target "indesign" и т.п., где будет присутствовать своё глобальное свойство `app` - нужно пользоваться другой практикой:

```js
var myApp = new MVCApplication();

myApp.Init = function() {
    // получаем локальную ссылку:
    var app = this;
    // и далее можем везде ей пользоваться:
    app.CreateMainView( /*...*/ );
    //... 

};

myApp.run();
```

В противоположность методу `.Init()`, предназначенному для предварительной инициализации приложения, объект `MVCApplication` предлагает стандартный обработчик `.onExit()`, который навешивается на событие `onClose` главного окна приложения (за что, также, отвечает метод `CreateMainView()`), тоесть — будет автоматически вызван в результате закрытия этого окна и может быть определён для выполнения неких завершающих действий после выхода из приложения:

```js
var myApp = new MVCApplication();

myApp.Init = function() {
    var app = this;
    app.CreateMainView("dialog                                \
                        {                                     \
                            btOk:Button { text:'Ok' },        \
                            btCancel:Button { text:'Cancel' } \
                        }");
    var w = app.window;
    
    w.btOk.onClick     = function() { w.close( app.exitcode = 1 ) };
    w.btCancel.onClick = function() { w.close( app.exitcode = 0 ) };
};

myApp.onExit = function(e) {
    // В зависимости от способа выхода в консоль будет выведено
    // соответствующее сообщение:
    $.writeln( this.exitcode ? "Ok" : "Отмена" );
};

myApp.run();
```

Для завершения знакомства с объектом `MVCApplication` следует перечислить полный список свойств, которые он содержит:

Свойство    | Тип          | Краткое описание 
----------- | ------------ | ----------------
id 			| {string}     | id - идентификатор объекта (не используется, по-умолчанию - пустая строка);
name 		| {string}     | наименование приложения;
version 	| {string}     | версия;
caption 	| {string}     | заголовок главного окна;
view 		| {string}     | ресурсная ScriptUI строка, описывающая окно;
window 		| {object}     | указатель на ScriptUI-объект - диалог, представляющий главное окно приложения;
mainView 	| {MVCView}    | указатель на основное Представление, инкапсулирующее главное окно Приложения;
models		| {Collection} | коллекция моделей;
views 		| {Collection} | коллекция представлений (`.views[0]` - всегда содержит ссылку на главное Представление, на которое так же всегда указывает свойство `.mainView`);
controllers	| {Collection} | коллекция контролёров.
exitcode	| {number}     | код завершения приложения (должен устанавливается явно, по умолчанию == undefined)

Полный список методов, предоставляемых объектом `MVCApplication`:

Методы | Краткое описание 
------ | ------
`CreateMainView(rсString);` | создаёт главное окно из ресурсной строки (rcString); 
`Init();` 					| выполняет начальную инициализацию;
`addController(obj);` 		| добавляет контроллёр в коллекцию контролёров `controllers`;
`addModel(obj);` 			| добавляет модель в коллекцию моделей `models`; 
`addView(obj);` 			| добавляет представление в коллекцию представлений `views`; 
`findController(obj);` 		| ищет и возвращает контроллер, ассоциированный с аргументом;
`getControllerByID(id);` 	| возвращает контроллер по `id`;
`getModelByID(id);` 		| возвращает модель по `id`;
`getViewByID(id);` 			| возвращает представление по `id`; 
`removeController(obj);` 	| удаляет контроллер из коллекции моделей;; 
`removeMVC(obj);` 			| удаляет связанные группы MVC-объектов; 
`removeModel(obj);` 		| удаляет модель из коллекции моделей;
`removeView(obj);`  		| удаляет представление из коллекции представлений;
`run();` 					| выполнение `.Init()` и запуск приложения; 
`onExit(e);` 				| обработчик выхода из приложения (закрытия главного окна);

Все методы и свойства подробно описаны в *html*-документации, а также рассматривается далее в этом руководстве.

<h4 id="Model"><a href="#Model">
    MVCModel
</a></h4>

**Модель**, согласно архитектурному паттерну MVC, это базовый объект пользовательских данных, который содержит как сами данные, так и соответствующую логику по работе с ними. Под логикой подразумеваются методы для конвертации, валидации, вычисления свойств, контроля доступа и каких угодно операций со свойствами самой Модели.

Модели - объекты-`MVCModel`, на самом деле, представляют собой небольшую «обёртку» над пользовательскими данными, которая позволяет связывать эти данные с представлениями с тем, чтобы иметь простой механизм отображения и редактирования этих данных.

Модель, как и любой другой MVC-объект, можно создать путём использования оператора `new` и конструктора, или с помощью соответствующего метода Приложения — *.addXxxx(...)*. И в первом и во втором случае будут созданы идентичные объекты, с той лишь разницей, что методы группы addXxxx (`.addModel()`, `addView()`, `addController`) не только создают объекты, но сразу добавляют их в соответствующие коллекции и дополнительно выполняют ещё ряд действий, необходимых для их инициализации. Как правило, для создания MVC-объктов, в том числе и Моделей, нет необходимости использовать их "родные" конструкторы, достаточно в контексте объекта-Приложения выполнить соответствующий метод addXxxx(), указав ему аргументы, предназначенные для соответствующего конструктора. Метод `.addModel()` в качестве аргумента принимает литерал объекта, используемый для создания и настройки Модели:

```js
// myApp – созданный ранее объект MVCApplication:
var myData = myApp.addModel({
	// совсем не обязательно, чтобы значение id совпадало
	// с локальным именем переменной, как в этом примере,
	// однако для читаемости кода это полезно!
    id:"myData", 
    // далее определяются все необходимые данные и
    // методы модели:
    value:{ txt:"Мои данные" },
    print:function() { $.writeln(this.value.txt) }
});

myData.print(); 							 // => `Мои данные`
$.writeln(myData.id == "myData");      		 // => true
$.writeln(myData instanceof MVCModel); 		 // => true
$.writeln(typeof myData); 			   		 // => object
$.writeln(myData.value.txt == "Мои данные"); // => true
```

Все MVC-объекты обладают свойством **`id`**, которое представляет собой произвольное текстовое значение. Это свойство выступает в качестве их имени, и используется везде: при поиске и получении их из коллекций, при связывании (моделей и представлений), при удалении и т.п. В объявлении объекта его всегда можно упускать, в таком случае оно будет сгенерировано автоматически, в противном случае объект получит значение, заданное в объявлении в поле `id`. Задавая `id` явным образом — требуется самостоятельно позаботится о том, чтобы у объектов одного класса (в пределах одной коллекции) эти значения были уникальными.

> например, объект `MVCModel` и соответствующий ему `MVCView` могут иметь одинаковые значения **`id`**, но два объекта `MVCModel` или два объекта `MVCView` — не могут. Методы приложения `.addXxxx()` умеют самостоятельно отслеживать и генерировать уникальные `id` для каждой группы объектов.

Создавая Модель с использованием конструктора, потребуется явно добавлять Модель в соответствующую коллекцию — `MVCApplication.models`, иначе не будет корректно работать механизм диспетчеризации событий между Моделями и Представлениями. В следующих примерах представлено создание моделей - аналогичных предыдущий из примера:

```js
// Два способа создания Моделей с помощью конструктора:
// ПРИМЕР 1) последовательное создание и расширение:
var myModel = new MVCModel("myModel");  // Родительский конструктор автоматически определит
										// текстовую строку как значение свойства id. 
myModel.value = {txt:"Мои данные"};
myModel.print = function() { $.writeln(this.value.txt) }

// ПРИМЕР 2) создание на основе литерала (аналогично addModel({...})):
var myData = new MVCModel({
    id:"myData", 
    value:{ txt:"Мои данные" },
    print:function() { $.writeln(this.value.txt) }
});	

// В любом случае, для связывания с представлениями, модель
// потребуется явно добавить в коллекцию моделей приложения:
myApp.models.add(myModel);
```

Дополнительно, в объекты `MVCModel` обладают таким свойством как состояние (валидность) и предоставляет пару специальных методов: 

* `.isValid()` - возвращает состояние модели (по умолчанию всегда - **true**); 
* `.validator()` - специальная функция-валидатор, предназначенная для управления состоянием Модели, при обновлении значений её свойств. 

После связывания Модели с Представлением, валидатор автоматически вызывается диспетчером Приложения каждый раз при обновлении какого либо свойства Модели со стороны скрипта или связанного с ней Представления. Функция-валидатор при вызове (подобно функции Object.prototype.watch()) получает заранее определённые аргументы, её полная сигнатура имеет вид: `validator(key, oldVal, newVal, ctrl)`, где:

* key:{string}             - имя изменившегося свойства;
* oldVal:{any}             - старое значение свойства;
* newVal:{any}             - новое значение свойства;
* ctrl:{MVCController}     - ссылка на контролёр, в контексте которого произошёл вызов валидации.

Функция подробно описана в *html*-документации. Следующий пример демонстрирует её использование:

```js
// ПРИМЕР 1: 
// Данная модель будет валидна только если 
// свойство operand - число:
myApp.addModel({
	id:"model",
	val: 100,
	validator:function(key, oldVal, newVal) {
		return isNaN(newVal); 
	} 
});

// ПРИМЕР 2: 
// модель будет валидна только если длинна строки 
// в свойстве val.txt меньше 10:
myApp.addModel({
	id:"model",
	val { value:100, txt:"Строка" },
	validator:function(key, oldVal, newVal, ctrl) {
		// Выполняется анализ только в связи с
		// изминением свойства 'txt':
		if (key == 'txt') {
			// тут может находится 'тяжёлый' код
			// проверки дополнительных условий:
			// if (ctrl.view.control.visible) { ... }
			// ...
			return (newVal.toString().length < 10); 
		} else {
			// для всех прочих событий валидации -
			// просто возвращаем текущее состояние:
			return this.isValid();
		}
	} 
});
```
<h4 id="View"><a href="#View">
    MVCView
</a></h4>

**Представления** (или в другой терминологии – **Вид**), представлены типом `MVCView` и служат для отображения данных модели (с возможностью их редактирования). По сути,  `MVCView` является обёрткой вокруг ScriptUI-элементов управления графического интерфейса, которые они инкапсулируют в себе. Это кнопки, списки, текстовые поля и т.д. Определённое свойство модели связывается с определённым свойством представления. Например, свойство `value.text` модели, из предыдущих примеров, может быть связано со свойством text инкапсулированного в представлении элемента управления `EditBox`. Связывание обеспечивает двунаправленную связь между соответствующими свойствами моделей и представлений. Любое изменение связанного свойства модели будет отражаться на значении заданного свойства представления и наоборот. При этом, в результате связывания, даже если свойство модели изменяется в скрипте без участия пользователя, значение связанного поля в представлении (в элементе управления) также изменится и в тот же момент может быть автоматически отражено в диалоге и на экране.

Связывание Моделей и Представлений реализуется в декларативном стиле, обеспечивается объектом-контролёром `MVCController` и  подробно рассматривается в разделе, посвящённом описанию Контролёров. 

Как и в случае с Моделями — существует два основных пути создания Представлений: с помощью конструктора `MVCView()` и с помощью метода приложения `.addView()`, однако, в отличии от истории с моделями, — для представлений эти два способа существенно различаются. В первую очередь это связано с тем, что конструктор не отвечает за создание самого элемента управления, он лишь предназначен для *"оборачивания"* уже существующего, в то время как метод `.addView()` используется для создания одновременно и самого объекта `MVCView` и элемента управления, который в нём инкапсулируется.

##### Использование конструкторов для создания Представлений:

Вызов конструктора без параметров `var myView = new MVCView();` возвращает базовый `MVCView`-объект - пустышку, сигнатуру которого можно представить следующим образом:

```js
var myView = new MVCView();
// полученная сигнатура myView:
myView = {
    // Свойства изначально определённые для MVCView:
    id:{string} = "view",		// идентификатор
    control:{object} = Null,	// указатель на ел.управления ScriptUI
    view:{string} = "",			// ресурсная строка, представляющая ScriptUI объект,
    							// на который указывает свойство control

    // Методы изначально определённые для MVCView:
    Init();      // метод инициализации – реально в контексте MVCView не определён
    onRemove();  // обработчик удаления – изначально в контексте MVCView не определён
    rebind(model, view_key, model_key);
    remove();
    unbind();
}
```

Сейчас нас интересуют только свойства. Видно, что мы получили объект-пустышку, не представляющую реально никакого Представления или Вида. Единственное — конструктором было автоматически проинициализировано свойство id значением по умолчанию "view". Полная сигнатура конструктора предусматривает передачу от одного до трёх параметров (любой из них являются необязательным и все они могут передаваться как объект с параметрами):

```js
// получает один, два или три аргумента:
MVCView(id /* string */, [ control /* object */, view /* string */ ]);

// альтернативная форма вызова с использованием объекта с параметрами -
// вызов с одним аргументом (основные поля тоже не обязательны, кроме id):
MVCView({ 
	id:"view_10",  /* string */  
	control:w.grp, /* ScriptUI object */ 
	view:rcString  /* string */
});
```

С параметром `id` всё просто — он будет присвоен собственному свойству `MVCView.id` Второй параметр `control` – должен указывать на некий, уже существующий графический элемент управления (ScriptUI объект – кнопка, список, диалог и т.п.). Третий параметр rcString — представляет текстовое значение, которое описывает графический элемент управления в формате ресурсной строки ScriptUI. Тоесть такой строки, которая указывается в качестве параметра при вызове метода add() в отношении диалогового окна: `Window.add(rcString)`, или другого ScriptUI-объекта контейнерного типа. Если строку не указать (использовать только два аргумента при вызове конструктора) — строка будет сформирована автоматически с помощью самого объекта control, в отношении которого (для получения «правильной» строки) будет вызван метод `control.toSource()`, а результат присвоен собственному свойству `MVCView.view`. Главное, чтобы параметр control представлял реальный ScriptUI-объект – уже существующий элемент управления или диалоговое окно. Если же параметр rcString указать — никакой специальной обработки или проверки не происходит, значение, как есть, будет присвоено свойству view объекта MVCView. 
Таким образом, создание Представлений с использованием конструктора `MVCView()` требуется в случае, когда необходимо существующий элемент управления «обернуть» в Представление. В последующем, такое представление можно полноценно использовать в архитектуре MVC приложения, связывать его с Моделями, расширять и дополнять его требуемыми свойствами, методами, обработчиками и т.д.

Пример, пусть мы имеем диалоговое окно с парой элементов управления EditText:

```js
var w = new Window("dialog { et1:EditText{}, et2:EditText{} }"); 
```

Сформируем объект-Представление для первого элемента `EditText` этого окна:

```js
var myView = new MVCView("et1", w.et1);
// id было указано
$.writeln(myView.id);     // => `et1`
// свойство view было сформировано автоматически
$.writeln(myView.view);   // => `edittext {textDirection:null,type:edittext}`
// свойство control указывает на ScriptUI объект
$.writeln(myView.control === w.et1); // => true
```

Использованием «родных» конструкторов MVCView() для создания Представлений практикуется довольно часто. Однако, как и в случае с Моделями, полученное Представление перед связыванием потребуется явно добавить в коллекцию `views` объекта `MVCApplication`:

```js
myApp.views.add(myView); // myApp – ранее созданный объект MVCApplication
```

##### Использование метода MVCApplication.addView() для создания Представлений:

В отличии от работы конструктора `MVCView()`, результатом работы метода `addView()` всегда будет создание нового элемента управления и, соответственно, нового объекта-представления, которое будет автоматически добавлено в коллекцию представлений приложения и, в случае необходимости, ему будет сформирован уникальный `id`. Метод `addView()` ожидает получить единственный параметр в виде литерала объекта со следующими полями:

```js
// полная сигнатура метода приложения addView():
var myView = MVCApplication.addView({ 
    id:{string}, 				// id объекта 
    parent:{ScriptUI object}, 	// родительский контейнер для ел.уп.
    view:{string},				// ресурсная строка для создания ел.управления
    control:{ 	// все свойства, заданные в рамках объекта control
        		// объединяются с создаваемым эл.управления.
    		// Например, перезапишется обработчик onChange:
        onChange:function() { /*...*/ },
			// и добавится новое свойство свойство “prop”:
        prop:{}
    },
    Init:{function},   	// функция-инициализатор для эл.управления
    render:{function}  	// Обработчик, вызываемый когда требуется обновить
        		     	// представление в связи с обновлением модели.
});
```

Обязательным полем здесь является только поле `view`. Оно описано обязано содержать корректную ScriptUI-строку, представляющую создаваемый элемент управления. Значение этого поля будет использовано  в качестве параметра при вызове метода `parent.add(view)` в отношении либо главного окна приложения (MVCApplication.window если свойство parent отсутствует), либо в отношении элемента, на которое будет указывать свойство `parent` (если это свойство задано). Таким образом, свойство `parent` должно указывать на элемент управления, представляющий ScriptUI-объект контейнерного типа: group, panel, tabbedpanel, tab, dialog, palette или window (должно обладать методом `.add()` это также могут быть списки и деревья). Самостоятельно это свойство в объекте `MVCView` отсутствует и используется только на этапе создания элемента управления. Если нужно — «родителя» элемента управления можно получить обратившись к его свойству parent: `myView.control.parent`

В результате создания элемента, полученный ScriptUI-объект будет присвоен собственному свойству `control` создаваемого представления `MVCView`. На следующем шаге произойдёт слияние объекта, заданного литералом в поле control, с полученным на предыдущем шаге ScriptUI-элементом управления (конечно, если это поле control было определено в литерале). В результате слияния свойства в объекте ScriptUI будут объединены со свойствами, определёнными в объекте-литерале `control`, а одноимённые свойства будут перезаписаны. В результате MVCView.control будет указывать на сформированный ScriptUI объект. Как правило, в рамках поля `control` в литерале удобно определять обработчики событий и прочие собственные свойства элементов управления, которые неудобно или невозможно задавать в ресурсной строке в параметре `view`.

Поле `Init` имеет схожее назначение с методом `Init()` объекта-приложения. Оно инициализируется функцией, которая вызывается в контексте элемента управления (this в контексте вызова Init() будет соответствовать контексту  объекта `MVCView.control`, но не самого объекта `MVCView`). Данная функция предназначена для выполнения дополнительной инициализации элемента управления после его создания. Например, в результате выполнения следующего кода будет создан новый объект MVCView, представленный элементом управления `ListBox`, который добавляется к главному окну приложения. Сразу после создания объекта ListBox в отношении него будет вызван метод, заданный свойством Init, и к списку будет добавлено две строки, при этом сам метод в последствии никак не привязывается к объекту MVCView или к элементу управления (он используется однократно только при создании элемента управления):

```js
myApp.addView({ 
    view:"listbox { characters: 20 }", 
    Init:function() {
        this.add("item", "Строка 1");
        this.add("item", "Строка 2");
    }
});
```

Свойство `render` будет добавлено непосредственно к объекту `MVCView`. Оно представляет функцию, которая будет вызываться в контексте элемента управления (в контексте объекта `MVCView.control`, но не самого `MVCView`) каждый раз, когда требуется обновить представление (сам элемент управления) в связи с событием обновлением модели. Метод вызывается автоматически и получает заранее предопределённые параметры, в которых содержаться информация: ссылку на контролёр, связанный с этим представлением, старое и новое значение свойства, которое изменяется, имя этого свойства. Полная сигнатура метода и параметры описаны ниже, в разделе описания методов объекта `MVCView`. Следующий пример демонстрирует определение метода рендеринга, который отвечает за смену цвета надписи в своём элементе управления в зависимости от состояния модели:

```js
myApp.addView({
	id:"edit",
	view:"edittext",
	render: (ctrl) {
        var gfx = this.graphics;
        // меняем цвет текста в зависимости от состояния модели:
        if (ctrl.model.isValid()) { 
            // gfx.PenType.SOLID_COLOR == 0
            gfx.foregroundColor = gfx.newPen (0, [0,0,0], 1); 
        } else {
            gfx.foregroundColor = gfx.newPen (0, [1,0,0], 1);
        }
    }
});
```

В результате всех действий, включая инициализацию Представления, метод `MVCApplication.addView()` возвращает созданный объект `MVCView`, предварительно добавив его в коллекцию представлений `MVCApplication.views` и, в случае необходимости, самостоятельно сгенерирует или проверит на уникальность значение `id` этого объекта.

Для завершения предварительного знакомства с `MVCView` предлагается пример законченного MVC-приложения c использованием валидаторов модели и заказным рендерингом представления:

```js
// --------------------------------------------------------------------
// Пример использования валидатора модели одновременно с 
// пользовательской функцией рендеринга представления.
//
// Если введённое значение не число - подкрасит поле редактирования
// и изменит текст всплывающей подсказки:
// --------------------------------------------------------------------
#include "MVC.jsx"

var myApp = new MVCApplication({ caption:"Введите число" });
myApp.Init = function() {
    var app = this,
        w = app.window;
    // настройка главного окна
    w.orientation = 'row';
    w.add("statictext {text:'Введите чило: '}");
    // --------------    
    // Представление:
    app.addView({
        id:"view",
        view:"EditText { characters:20 }",
        render:function(ctrl, newVal) {
            var gfx = this.graphics,
                status = ctrl.model.isValid();
            // красный, если модель не валидна:
            // gfx.PenType.SOLID_COLOR == 0
            gfx.foregroundColor = gfx.newPen(0, [(status ? 0 : 1),0,0], 1);
            this.helpTip = (status ? "Число: " + newVal : newVal + " не является числом");    
        }
    });

    // --------------    
    // Модель:
    app.addModel({
        id:"model",
        value:10,
        // Возвращает false если значение не число:
        validator:function(key, oldVal, newVal, ctrl) {
            return !isNaN(newVal);
        }
    });
    
    // --------------    
    // Контролёр:  
    app.addController({ binding:"model.value:view.text" });
}; // Init()

myApp.run();
```

> Код может показаться избыточным и действительно, всё можно было бы решить, обойдясь одним обработчиком onChanging в элементе управления:
>
> ```js
> 	var w = new Window("dialog { text:'Введите число',      \
> 	                             view:EditText { text:'10', characters:20 } \
> 	                   }");
> 	w.view.onChanging = function() {
> 	    var gfx = this.graphics,
> 	        status = !isNaN(this.text);
> 	    gfx.foregroundColor = gfx.newPen(0, [(status ? 0 : 1),0,0], 1);
> 	    this.helpTip = (status ? "Число: " + this.text : 
> 	                    this.text + " не является числом");
> 	}
> 	w.show();
> ```
>
> Данный код работает совершенно аналогично приведённому выше примеру. Однако, главное отличие заключается в том, что данный код демонстрирует смешивание логики и представления. Подход и главная парадигма архитектуры MVC заключается в том, чтобы максимально разделить эти два аспекта. Это достигается путём размещения всей логики по работе и анализу данных в модели, а представление лишь реагирует на состояние модели, оно вовсе не обязано знать как валидировать модель и как с ней работать, модель делает это самостоятельно. 
>
> Такой подход позволяет чётко отделить логику по работе с данными от логики по их отображению. Истинная польза такого разделения не требует особых комментариев, на эту тему написано множество книг и целых фолиантов. Библиотека MVC позволяет в полной мере реализовать этот подход и польза от такого разделения увеличивается пропорционально увеличению и сложности самого приложения.
>
> > **Когда имеет смысл смешивать логику обработки данных с Представлениями:**
> > 
> > При разработке **специализированных Представлений** это вполне допустимо. Например, совершенно нормально разрабатывать представление исключительно для отображение данных определённого типа или соответствующих определённому шаблону. В этом случае анализ этих данных уместно проводить в обработчиках событий или специализированных методах в контексте самих представлений или графических элементов управления. Примерами таких специальных представлений могут служить т.н. *MeasurementEditboxes* и т.п., для работы сугубо с числами, датами, имейлами и т.д.


##### Методы объекта MVCView:
```js
	onRemove();
```

Вызов данного обработчика происходит в момент удаления объекта Представления непосредственно перед удалением графического элемента управления, представленного в данном объекте `MVCView`. По умолчанию обработчик не выполняет никаких действий.

```js
	rebind(model, [ view_key, [model_key] ])
```

Метод предназначен для переключения (перепривязки) Представления на новую Модель, заданную параметром `model`. Параметры `view_key` и `model_key` не обязательные. После переключения все события, связанные с изменением свойства `view_key` данного представления будут приводить к соответствующему изменению указанной модели. Параметр view_key по умолчанию имеет значение “text”. Если упущено не задано свойство для модели (model_key) — происходит попытка определить его автоматически - на основании свойства binding, полученного от контролёра, ранее связанного с данной моделью. После переключения, функция просто возвращает свой аргумент model.

```js
	remove()
```

Удаление элемента управления из родительского контейнера. Как правило, специальный вызов данного метода не требуется. Данный метод вызывается автоматически при удалении объекта Представления в результате вызова методов приложения `MVCApplication.removeView()` или `MVCApplication.removeMVC()`. Вызова данного метода приводит к срабатыванию  обработчика onRemove(). Он вызывается непосредственно перед удалением елемента управления ScriptUI и может быть определён для выполнения каких либо дополнительных действий. Переопределение метода `remove()` не требуется.

```js
	render(key, newVal, oldVal, ctrl)
```

Изначально данный метод никак не объявлен и не определён в объекте `MVCView`. Тем не менее, диспетчером событий Приложения предусмотрен вызов данного метода каждый раз при обновлении свойства Представления, вызванное обновлением свойства Модели, связанной с данным представлением. Вызов происходит в контексте графического элемента управления. Этот метод можно определять, для задач, связанных с управлением внешним видом элемента управления, инкапсулированного в данное представления, в зависимости от сложившихся условий в результате обновления модели. Например, можно контролировать внешний вид Представления на основе значения, возвращаемого методом `isValid()` в отношении связанной модели. Метод получает следующие аргументы:

* **`ctrl`** - ссылка на объект Контроллер, связанный с данным представлением;
* **`newVal`** - новое значение свойства;
* **`oldVal`** - старое значение свойства;
* **`key`** - имя свойства представления, которое изменилось.

```js
	unbind()
```

«Отвязывает» Представление от Модели, при этом связанное свойство представления очищается (ему присваивается пустая строка "" или null, если этим свойством является свойство selection). В результате отвязывания, события изменения свойства Представления больше не отражаются на значении соответствующего свойства Модели. Однако, события изменения свойств у ранее привязанной Модели по прежнему будут приводить к обновлению Представления. Чтобы полностью разорвать связь между Представлением и Моделью необходимо выполнить метод disable() в отношении Контролёра, связывающего эти объекты.


<h4 id="Controller"><a href="#Controller">
    MVCController
</a></h4>

Контролёры обеспечивают «связывание» Моделей и Представлений. Связывание обеспечивает двухстороннюю привязку значений заданных свойств Модели к заданным свойствам Представления. Модель, а точнее – определённое свойство модели, может быть привязано к нескольким различным представлениям (к их свойствам). Таким образом, любое изменение связанного свойства модели будет приводить к соответствующему изменению заданного свойства во всех связанных с ним представлениях. В то же время, изменения свойства в представлении приводит к изменению связанного свойства в модели.
Связывание определяется в декларативном стиле в виде строки, описывающей пару связываемых MVC-объектов и связываемых в них свойствах. Эта строка представлена свойством `binding` в объекте `MVCController` и является ключевым моментом в определении контролёра (она условно называется «строкой биндинга» или строкой связи).

Чтобы связать Модель и Представление, необходимо создать контроллер и указать в строке `binding` что именно будет связано. Проще всего это понять на шаблонном примере полноценного MVC-приложения:

```js
// Подключаем библиотеку:
#include "MVC.jsx"

// Создаём объект-приложение:
var myApp = new MVC.Application();

// Функция инициализации:
myApp.Init = function() {
    var app = this;
    
    app.addModel({ 
        id:"myData", 
        value:{ txt:"Мои важные данные" } 
    });

    app.addView({ id:"st", view:"statictext" });
    app.addView({ id:"et", view:"edittext" });
    
    app.addController({ binding:"myData.value.txt:st.text" });
    app.addController({ binding:"myData.value.txt:et.text" });
};

// Запуск приложения
myApp.run();
``` 

Из примера видно как происходит связывание — строка binding:"myData.value.txt:st.text" состоит из двух частей, справа определяется Модель, слева - Представление. В результате будет создано диалоговое окно со статической надписью и полем редактирования. Поскольку оба элемента управления связаны с одной и той же моделью — редактирование текста в текстовом поле элемента  `EditText` будет немедленно отражаться на статической надписи, представленной элементом `StaticText`.

> Строка биндинга в части ссылки на представление имеет несколько сокращённый формат: всегда предполагается, что задаётся свойство для элемента управления, находящегося в контексте представления, а не на свойство самого представления. Поэтому часть строки "st.text" всегда будет интерпретироваться как "st.control.text" - свойство `control` для представлений не указывается.

По умолчанию конструктор контролёра в момент связывания сразу синхронизирует значения Модели и Представления (значение свойства модели присваивается свойству представления), это можно изменить, указав значение false для логического флага `bind`:

```js
	app.addController({ binding:"myData.value.txt:st.text", bind:false });
```

При таком вызове значения синхронизируются при первом же изменении свойства в любом из связанных MVC-объектов.

Контролёры также допустимо создавать с использованием их конструкторов, но в данном случае необходимо знать, что Контролёры, в отличии от Моделей и Представлений - жёстко связаны с объектом Приложения, поэтому, в аргументах вызова конструктора необходимо обязательно указывать ссылку на родительский объект MVCApplication, в рамках которого создаётся Контролёр и связываются MVC-объекты. Эта ссылка будет присвоена собственному свойству `app` объекта `MVCControler`. Следующие три примера демонстрируют три формы использования конструктора Контролёра:

```js
var myCtrl = new MVCController(myApp, "myCtrl", { binding:"myModel.value.text:myView.text" });
var myCtrl = new MVCController(myApp, { id:"myCtrl", binding:"myModel.value.text:myView.text" });
var myCtrl = new MVCController({ app:myApp, id:"myCtrl", binding:"myModel.value.text:myView.text" });
```
Из примера видно, что Конструктор принимает один, два либо три параметра, первый трактуется как ссылка на приложение, если это не так — это должен быть комплексный объект с заданным свойством `app`, которое должно инициализироваться указателем на экземпляр *"родительского"* приложения (все поля в литерале аргумента обрабатываются тем же способом что и в конструкторе MVCObject). Далее — если на месте второго параметра окажется строка, она будет трактоваться как значение свойства `id`. Если указывается более двух параметров - первым всегда идёт указатель на приложение. Если параметр один - это обязан быть комплексный объект с обязатльным полем `app:` (иначе будет вызвано исключение).

Создание Контролёра без свойства `binding` возможно, однако на практике лишено особого смысла. Аналогично, нет вообще никакой особой необходимости в использовании *"родных"* конструкторов для создания контролёров. Наиболее простой и продуктивный способ определения контролёров заключается в использовании метода приложения: `MVCApplication.addController({...})`, при котором достаточно указать свойство `binding:` и, если нужно, `bind:`, при этом не нужно заботится не о ссылке на экземпляр приложения, не о значении свойства `id`.

Функциональные возможности объектов контролёров предельно лаконичны. Все сложная работа по синхронизации и диспетчеризации событий между Моделями и Представлениями скрыта под-капотом. А на верху — это всего два метода, которые позволяют при необходимости включать и отключать связь между парой связанных MVC-объектов. Чтобы это сделать нужно в контексте необходимого контролёра вызвать методы `.enable()` и, соответственно, `.disable()`. Это может понадобиться, например, для обновления комплексной модели, большое кол-во свойств которой связано с представлениями (например списки), в этом случае, чтобы не тратить время на последовательные обновления графического интерфейса, полезным будет приостановить связь этой модели с представлением, вызвав метод `.disable()`, а после обновления - возобновить связь, вызвав `.enable()`.

##### Свойства объекта MVCController

Одна из основных идей и задач MVC архитектуры - обеспечить максимальное разделение между данными и их представлениями. Модели и Представления практически ничего не знают друг о друге, их взаимодействие обеспечивается благодаря контролёрам, которые их связывают. Поэтому каждый контролёр обладает ссылками на пару связанных Модели и Представления. Эти ссылки представлены в его свойствах:

Свойство  | Тип              | Описание
----------|------------------|---------
app       | {MVCApplication} | указатель на "родительское" приложение (задаётся при создании Контролёра);
binding   | {string}         | строка биндинга;
model     | {MVCModel}       | указатель на Модель, связанную с данным контролёром;
model_key | {string}         | имя связанного свойства Модели; 
model_obj | {object}         | указатель на родительский в отношении `model_key` объект;
view      | {MVCView}        | указатель на Представление, связанное с данным контролёром; 
view_key  | {string}         | имя связанного свойства Представления. 
view_obj  | {object}         | указатель на родительский в отношении `view_key` объект (как правило, это объект UIControl)

Наибольшее практический интерес в Контролёрах вызывают его свойства. Свойства группы `model*` и `view*` инициализируется на основе парсинга строки `binding` в процессе создания контролёра и указывают на соответствующие Модель и Представление. Например, парсинг строки:

```js
// из шаблонного примера MVC-приложения: 
var ctrl = myApp.addController({ binding:"myData.value.txt:et.text" });
```

Приведёт к установке соответствующих ссылок к следующим значениям:

* `ctrl.model === myData` - свойство `model` будет указывать на объект `MVCModel` в коллекции `app.models` - модель myData;
* `ctrl.model_key === "txt"` - свойство `model_key` будет содержать строку "txt" - имя связанного свойства модели;
* `ctrl.model_obj === myData.value` - свойство `model_obj` будет указывать на родительский объект, в контексте которого находится связанное свойство модели "txt";

Аналогично будут проинициализированы свойства для Представления:

* `ctrl.view === et` - свойство `view` будет указывать на объект `MVCView` в коллекции `app.views` - представление et, инкапсулирующие элемент управления EditText;
* `ctrl.view_key === "text"` - свойство `view_key` будет содержать строку "text" - имя связанного свойства представления;
* `ctrl.view_obj === et.control` - свойство `view_obj` будет указывать на родительский объект, в контексте которого находится связанное свойство представления, в данном случае это ссылка на et.control, потому, что свойство представления `MVCView.control` как раз указывает на объект ScriptUI, в данном случае это объект EditText, а свойство "text" находится именно в контексте EditText;

Таким образом имеем следующие справедливые равенства: `ctrl.model_obj[ctrl.model_key] === myData.value.txt` и `ctrl.view_obj[ctrl.view_key] === et.control.text`.

Знание того, что имея контролёр, мы можем получить любые данные из связанных Модели и Представления очень важно. В разработке  приложений со сложным интерактивным интерфейсом, часто возникает необходимость получить данные Модели из, например, обработчика события представления. Как это сделать, если Представление ничего не знает о модели и даже не содержит на него ни одной ссылки? Очень просто! Во первых, нужно получить контролёр, связанный с нашим представлением, а получив контролёр - можно получить ссылку на любое свойство и метод модели. Для поиска и получения ссылок на контролёры из соответствующей коллекции `MVCApplication.controllers` предназначены два метода приложения:

* `MVCApplication.getControllerByID(id)` - возвращает ссылку на контролёр по его `id`;
* `MVCApplication.findController(obj)` - получения контролёра связанного с объектом obj, используется если не известен `id` контролёра;

С первым методом всё просто, получает текстовое id, возвращает `MVCController` или `undefined`. Наиболее интересен второй метод, он может получать что угодно, и если обнаружиться контролёр, связанный с этим чем-нибудь, он будет возвращен. Например, для объектов из предыдущих примеров все эти вызовы вернут один и тот же контролёр:

```js
myApp.findController(myModel); 
myApp.findController(myModel.value);
myApp.findController(myView);
myApp.findController(myView.control);
```

На практике, вызов этого метода чаще всего используется в контексте обработчиков событий элементов управления ScriptUI для получения ссылок на связанные с ними модели. Для этого в контексте обработчика события можно вызвать данный метод и в качестве параметра указать ему ссылку this:

 ```js
// вызов осуществляется в котексте обработчика onChange() элемента управления:
var ctrl = myApp.findController(this);

if (ctrl.model.isValid()) {
	// делаем что-нибудь...
}
// ...
```

Кроме того, объекты Контролёры обладают тремя приватными методами. Как правило, непосредственное обращение к ним не требуется но для полноты картины ниже приводится их описание:

```js
	_initBinding();
```

Прототипный метод, вызываемый конструктором `MVCController` для выполнения инициализации Контролёра. Он отвечает за парсинг строки биндинга и инициализацию всех своих внутренних свойств, навешивание *"наблюдателей"* на свойства модели и настройку обработчиков представления `onChange()` и `onChanging()`.  

```js
	_updateModel();
```	

Прототипный вспомогательный метод, реализует механизм обновления данных Модели при возникновении событий `onChange()` или `onChanging()` в элементах управления, ассоциированных с соответствующими Представлениями. Данный метод используется для замещения стандартных обработчиков в элементах управления.

```js
	_updateView(newVal, oldVal, key);
```

Прототипный вспомогательный метод, вызывается в диспетчере MVCApplication и реализует обновление свойства Представления в связи с событием обновления связанного свойства в Модели. В качестве аргументов методу передаются три аргумента: newVal – новое значение свойства модели; oldVal – предыдущее значение свойства модели; key – имя свойства в модели, которое изменяется. Непосредственное обращение к данному методу как правило не требуется. Для осуществления контроля над процессом обновления в Представлениях существует специальный обработчик render(), рассчитанный на переопределение в пользовательском приложении.

Следующий пример демонстрирует совместное использование валидаторов моделей и пользовательского рендеринга представлений. Пример несколько надуманный, но он показывает как работают валидаторы моделей, как осуществляется управление отображением представления, как и для чего получаются ссылки на модели в обработчиках представлений и в каких случаях может быть полезно непосредственное использование специальных методов контролёра:

```js
// --------------------------------------------------------------------
// Пример использования валидатора модели одновременно с 
// пользовательской функцией рендеринга представления.
//
// Рисует диалоговое окно с полем редактирования данных
// модели. Если строка данных длиннее 10 символов - модель
// считается не валидной.
// Отображение модели происходит одновременно в нескольких
// связанных с ней представлениях.
// --------------------------------------------------------------------

#include "MVC.jsx"

// 
var myApp = new MVC.Application({ 
        view:"dialog { properties:{resizeable:true} }" 
    });

// Инициализация:
myApp.Init = function() {
    var app = this;
    
    // редактируемая модель
    app.addModel({
        id:"myData",
        value:{ txt:"Очень длинный текст, его можно редактировать." },
        validator:function(key, oldVal, newVal, ctrl) {
            return (newVal.length < 10 || newVal.length > 30) ? false : true;
        }
    });

    // модель-надпись для кнопки очистки
    app.addModel({ 
        id:"myData_2",        
        value:{ txt:"Очистить заголовок окна" },
    });

    // Добавляем представления:
    app.addView({ id:"st", view:"statictext" });
    app.addView({ id:"st1", view:"statictext { alignment:'left' }" });

    // Это представление предназначено для редактирования данных модели:
    app.addView({ 
        id:"et", 
        view:"edittext { characters:30 }", 
        // полная сигнатура параметров метода (ctrl, newVal, oldVal, key):
        // будет вызываться каждый раз при обновлении модели:
        render:function(ctrl) {
            var gfx = this.graphics;
            gfx.foregroundColor = gfx.newPen (0, [(ctrl.model.isValid() ? 0 : 1),0,0], 1);
        }, 
        // Расширяем элемент управления
        control:{
            onChanging:function() {
                   // получаем объект-контролёр, ассоциированный с данным представлением:
               var ctrl = app.findController(this),
                   // получаем ссылку на модель-надпись для кнопки очистки
                   model = app.getModelByID("myData_2"),
                   // получаем ссылку на кнопку
                   btOk = app.getViewByID("btOk").control;
                   
               // Поскольку мы переопределили обработчик onChanging - контролёр уже не 
               // сможет корректно обновить модель, поэтому это нужно сделать явно:
               ctrl._updateModel();
               
               // в зависимости от состояния меняем всплывающую подсказку и включаем
               // или выкбчаем кнопку btOk:
               if (ctrl.model.isValid()) {
                   btOk.enabled = true;
                   this.helpTip = "Всё хорошо!"; 
               } else {
                   btOk.enabled = false;
                   this.helpTip = "Строка не корректной длинны!";
               }

               model.value.txt = "Очистить заголовок окна";
            }, 
            // Вызываем сообщение об ошибке каждый раз при попытке смены фокуса 
            // с элемента управления, если с моделью в этот момент что-то не в порядке: 
            onChange:function() {
                var ctrl = app.findController(this);
                // Проверка статуса состояния модели:
                if (!ctrl.model.isValid()) { 
                    alert( "Проверьте ввод! \
                            В строке данных содержаться некорректные данные!\n \
                            Строка слишком " + (this.text.length < 10 ? 
                                                       "короткая." : "длинная."), 
                            ctrl.app.name, 
                            true);
                }
            }
        }
    });

    // Данное представление инкапсулирует кнопку для очистки заголовка главного 
    // окна приложения:
    myApp.addView({
        id:"bt", view:"button", 
        control:{
            helpTip:"Click me!",
            onClick:function() {
                // обновляем заголовок главного окна:
                app.window.text = app.caption;
                // меняем надпись на кнопке:
                app.getModelByID("myData_2").value.txt = "Готово!";
            }
        }
    });     

    // Представление для кнопки выхода из приложения. 
    // В случае если модель myData имеет некорректный статус, 
    // данная кнопка становится неактивной.
    app.addView({  
        id:"btOk", 
        view:"button { text:'Ok' }",
        // Делаем кнопку изначально неактивной
        Init:function() {
            this.enabled = false;
        },
        // Кнопка "Ok" для palette не закрывает окно так, как это происходит 
        // для dialog, поэтому делаем это явно (эта необходимость вызвана 
        // особенностью ScriptUI а не MVC):
        control:{ 
            onClick:function() { 
                app.window.close();
            }
        }
    });

    // Добавляем контроллёры
    app.addController({ binding:"myData.value.txt:st.text" });
    app.addController({ binding:"myData.value.txt:st1.text" });
    app.addController({ binding:"myData.value.txt:et.text" });
    // Связываем модель ещё и с заголовком главного окна приложения:
    app.addController({ binding:"myData.value.txt:window.text" }); 
    // привязаваем модель-подпись к представлению-кнопке:
    app.addController({ binding:"myData_2.value.txt:bt.text" });    
};

// Запуск приложения:
myApp.run();
```

<h2 id="todomvc"><a href="#todomvc">
    // TODO:
</a></h2>

* библиотека имеет довольно слабую связь с инструментами из ***_debug.jsx*** и ***_util.jsx***. Фактически, используются только пара методов, таких как `extend()` и `merge()` - из _util.jsx; и `log()` - из _debug.jsx. Возможно, в ближайшее будущее я полностью отвяжу её от этих компонентов, как в своё время отвязал модуль **Collection**. На интерфейсе библиотеки это ни коим образом не отразиться;
* я думаю, в библиотеке стоит отказаться от использования *интернационализации* (файлы *locales.jsxinc* в папке с исходниками), скорее всего эта фича исчезнет из следующей версии;
* Подумываю о расширении базового набора MVC - объектом MVCError и семейством типов на его основе. В них планирую реализовать функционал, аналогичный функции `trace()` из *_debug.jsx*;
* У меня проблемы с синтаксисом **jsdoc** в комментариях, никак не выйдет нормально описать в нём свои модули, поэтому *html*-документация генерируется довольно криво.
* Считаю, что в целом библиотека сформировалась, каких либо глобальных обновлений для неё делать не планирую, разве что ошибки подчищать да логические косяки, как например с проблемой возврата и использования `exitcode`.

----------------------------------
<h2 id="contrib"><a href="#contrib">
    Contributing:
</a></h2>

**Author:** Вячеслав Бойко <slava.boyko@hotmail.com>

**License:** [Creative Commons Attribution-NonCommercial-ShareAlike 3.0](http://creativecommons.org/licenses/by-nc-sa/3.0/)

**RU:** РАЗРЕШЕНО СВОБОДНОЕ ИСПОЛЬЗОВАНИЕ ПРОИЗВЕДЕНИЯ, ПРИ УСЛОВИИ УКАЗАНИЯ ЕГО АВТОРА, НО ТОЛЬКО В НЕКОММЕРЧЕСКИХ ЦЕЛЯХ. ТАКЖЕ ВСЕ ПРОИЗВОДНЫЕ ПРОИЗВЕДЕНИЯ, ДОЛЖНЫ РАСПРОСТРАНЯТЬСЯ ПОД ЛИЦЕНЗИЕЙ CC BY-NC-SA.

**EN:** THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS PUBLIC LICENSE (''CCPL'' OR ''LICENSE''). THE WORK IS PROTECTED BY COPYRIGHT AND/OR OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS LICENSE OR COPYRIGHT LAW IS PROHIBITED.
